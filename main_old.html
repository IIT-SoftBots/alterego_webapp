<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Control Panel</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link rel="stylesheet" href="styles/main.css">
</head>



<body>
    <h1 class="title loading">Control Panel</h1>

    <div class="button-container loading">
        <div class="button-grid">
            <button id="powerBtn" class="control-button power-button">
                <i class="fas fa-power-off"></i>
                <span>Power</span>
            </button>
            
            <button id="startBtn" class="control-button start-button" disabled>
                <i class="fas fa-play"></i>
                <span>Start</span>
            </button>

            <button id="configBtn" class="control-button config-button" >
                <i class="fas fa-cog"></i>
                <span>Config</span>
            </button>

            <button id="homeBtn" class="control-button home-button" disabled>
                <i class="fas fa-home"></i>
                <span>Home</span>
            </button>

            <!-- <button id="resetBtn" class="control-button reset-button" >
                <i class="fas fa-undo"></i>
                <span>Reset</span>
            </button> -->
        </div>

        <div class="status-panel">
            <h3 style="margin-top: 0;">System Status</h3>
            <div class="status-item">
                <div id="powerStatus" class="status-indicator" style="background-color: #ef4444;"></div>
                <span>Power: Off</span>
            </div>
            <div class="status-item">
                <div id="batteryStatus" class="status-indicator" style="background-color: #22c55e;"></div>
                <span>Battery: 85%</span>
            </div>
            <div class="status-item">
                <div id="systemStatus" class="status-indicator" style="background-color: #eab308;"></div>
                <span>Status: Ready</span>
            </div>
        </div>
    </div>

    <script>
        const ROS_COMMANDS = {
            SETUP: 'source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash',
            CLEANUP: 'rosnode kill -a && killall -9 rosmaster',
            CLEAR_LOG: 'truncate -s 0 ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt'
        };

        const LAUNCH_COMMANDS = {
            ROSCORE: 'roscore',
            USB_DETECTOR: 'rosrun alterego_robot usb_ports_detector.py',
            IMU: 'roslaunch alterego_robot imu.launch AlterEgoVersion:=3',
            PILOT: 'roslaunch alterego_robot pilot.launch AlterEgoVersion:=3',
            BACKWARD: 'roslaunch alterego_backward_controller backward.launch AlterEgoVersion:=3',
            BODY_ACTIVATION: 'roslaunch alterego_robot body_activation.launch AlterEgoVersion:=3',
            BODY_MOVEMENT: 'roslaunch alterego_robot body_movement.launch AlterEgoVersion:=3',
            WHEELS: 'roslaunch alterego_robot wheels.launch AlterEgoVersion:=3'
        };

        // Aggiungi il codice per caricare lo stato al caricamento della pagina
        const initializeStates = () => {
            isPowered = loadButtonState('isPowered');
            isRunning = loadButtonState('isRunning');

            if (isPowered) {
                powerBtn.classList.add('on');
                startBtn.disabled = false;
                homeBtn.disabled = false;
                powerStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#powerStatus + span').textContent = 'Power: On';
            }

            if (isRunning) {
                startBtn.classList.add('running');
                startBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                systemStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#systemStatus + span').textContent = 'Status: Running';
            }

            // Mostra il contenuto dopo l'inizializzazione
            document.querySelectorAll('.loading').forEach(el => {
                el.classList.add('loaded');
            });
        };
    
        // Esegui l'inizializzazione appena possibile
        document.addEventListener('DOMContentLoaded', initializeStates);


        const powerBtn = document.getElementById('powerBtn');
        const startBtn = document.getElementById('startBtn');
        const configBtn = document.getElementById('configBtn');
        const homeBtn = document.getElementById('homeBtn');
        const powerStatus = document.getElementById('powerStatus');
        const systemStatus = document.getElementById('systemStatus');

        let isPowered = false;
        let isRunning = false;

        // Aggiungi queste funzioni per gestire il localStorage
        function saveButtonState(buttonId, state) {
            localStorage.setItem(buttonId, state);
        }
        function loadButtonState(buttonId) {
            return localStorage.getItem(buttonId) === 'true';
        }
        // Funzione per ottenere il nome del robot
        async function getRobotName() {
            const response = await fetch('/grep-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: 'grep -oP "(?<=export ROBOT_NAME=).*" ~/.bashrc' })
            });
            const data = await response.json();
            return data.output.trim();
        }
        async function checkNodeStatus(nodeName) {
            const response = await fetch('/grep-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rosnode list | grep ${nodeName}`
                })
            });
            const data = await response.json();
            return data.output.includes(nodeName);
        }
        async function getTopicValue(topic) {
            try {
                // Add retry mechanism
                let retries = 3;
                while (retries > 0) {
                    try {
                        const response = await fetch('/grep-command', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rostopic echo -n 1 ${topic}`
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (!data || !data.output) {
                            console.warn('No data received from topic:', topic);
                            return null;
                        }
                        
                        // Extract y value
                        const match = data.output.match(/y:\s*([-]?\d*\.?\d*)/);
                        if (!match) {
                            console.warn('Could not parse y value from:', data.output);
                            return null;
                        }
                        
                        return parseFloat(match[1]);
                    } catch (error) {
                        retries--;
                        if (retries === 0) throw error;
                        console.warn(`Retry attempt left: ${retries}`);
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
                    }
                }
            } catch (error) {
                console.error('Error reading topic:', error);
                // If it's an SSH error, try to reconnect
                if (error.message.includes('SSH') || error.message.includes('Channel open failure')) {
                    console.log('SSH connection lost, attempting to reconnect...');
                    // Notify user of connection issue
                    Swal.fire({
                        title: 'Connection Lost',
                        text: 'Attempting to reconnect...',
                        icon: 'warning',
                        showConfirmButton: false,
                        allowOutsideClick: false,
                        allowEscapeKey: false,
                        timer: 2000
                    });
                }
                return null;
            }
        }
        // First modify checkStability function to remove its loading alert
        async function checkStability(robotName) {
            return new Promise((resolve) => {
                let checkInterval;
                let consecutiveNullReadings = 0;
                const MAX_NULL_READINGS = 5;
                const POLLING_INTERVAL = 500;
                
                let stableStartTime = null;
                let lastCheckTime = Date.now();
                
                checkInterval = setInterval(async () => {
                    const now = Date.now();
                    if (now - lastCheckTime < POLLING_INTERVAL) {
                        return;
                    }
                    lastCheckTime = now;

                    try {
                        const value = await getTopicValue(`/${robotName}/imu/RPY`);
                        console.log('IMU value:', value, 'Time:', new Date().toISOString());
                        
                        if (value === null) {
                            consecutiveNullReadings++;
                            console.warn(`Null reading #${consecutiveNullReadings}`);
                            
                            if (consecutiveNullReadings >= MAX_NULL_READINGS) {
                                console.error('Too many failed readings, stopping stability check');
                                clearInterval(checkInterval);
                                resolve(false);
                                return;
                            }
                            return;
                        }
                        
                        consecutiveNullReadings = 0;
                        
                        if (value >= -0.2 && value <= 0.1) {
                            if (!stableStartTime) {
                                stableStartTime = Date.now();
                                console.log('Started stability timer');
                            }
                            
                            const stableTime = Date.now() - stableStartTime;
                            console.log('Stable for:', (stableTime/1000).toFixed(1), 'seconds');
                            
                            if (stableTime >= 2000) {
                                console.log('Stability achieved');
                                clearInterval(checkInterval);
                                resolve(true);
                                return;
                            }
                        } else {
                            if (stableStartTime) {
                                console.log('Stability lost, resetting timer');
                                stableStartTime = null;
                            }
                        }
                    } catch (error) {
                        console.error('Error in stability check:', error);
                    }
                }, POLLING_INTERVAL);
            });
        }
       // First, add this new function above the event listeners
        async function waitForArmMovement(robotName) {
            return new Promise((resolve) => {
                let checkInterval;
                const POLLING_INTERVAL = 500;

                const loadingAlert = Swal.fire({
                    title: 'Activating arms...',
                    text: 'Waiting for movement',
                    allowOutsideClick: false,
                    allowEscapeKey: false,
                    didOpen: () => {
                        Swal.showLoading();
                        
                        checkInterval = setInterval(async () => {
                            try {
                                const response = await fetch('/grep-command', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rostopic echo -n 1 /${robotName}/alterego_state/upperbody | grep left_meas_arm_shaft`
                                    })
                                });
                                
                                const data = await response.json();
                                if (data && data.output) {
                                    // Extract numbers from output
                                    const values = data.output.match(/[-]?\d*\.?\d+/g);
                                    if (values) {
                                        // Check if any value is non-zero
                                        const hasMovement = values.some(v => Math.abs(parseFloat(v)) > 0.01);
                                        console.log('Arm values:', values);
                                        
                                        if (hasMovement) {
                                            console.log('Movement detected');
                                            clearInterval(checkInterval);
                                            Swal.close();
                                            resolve(true);
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error checking arm movement:', error);
                            }
                        }, POLLING_INTERVAL);
                    },
                    willClose: () => {
                        clearInterval(checkInterval);
                    }
                });

                // Add timeout after 30 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    Swal.close();
                    resolve(false);
                }, 30000);
            });
        }
        function sendFetchCommand(command) {
            fetch('/execute', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ command: command }),
            })
            .then(response => response.text())
            .then(data => console.log(data))
            .catch(error => console.error('Error:', error));
        }
        function pingRemoteComputer() {
            return fetch('/ping', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ ip: '192.168.0.70' })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Ping successful:', data.success);
                return data.success;
            })
            .catch(error => {
                console.log('Ping failed:', error);
                return false;
            });
        }
        // Modifica gli event listener esistenti
        powerBtn.addEventListener('click', async () => {
            isPowered = !isPowered;
            saveButtonState('isPowered', isPowered);

            if (isPowered) {
                // Check if remote computer is online
                const isRemoteComputerOnline = await pingRemoteComputer();
                if (!isRemoteComputerOnline) {
                    Swal.fire('ERROR', 'Base computer not connected', 'error');
                    isPowered = false;
                    saveButtonState('isPowered', false);
                    return;
                }


                
                // Ottieni il nome del robot
                const robotName = await getRobotName();

                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.ROSCORE}`);
                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.USB_DETECTOR}`);
                   // Update UI
                powerBtn.classList.add('on');
                startBtn.disabled = false;
                homeBtn.disabled = false;
                
                powerStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#powerStatus + span').textContent = 'Power: On';

                // Initialize IMU
                const { value: initIMU } = await Swal.fire({
                    title: 'Calibration in Progress',
                    text: "Do not touch the robot during calibration.",
                    icon: 'warning',
                    showCancelButton: false,
                    allowOutsideClick: false,
                    allowEscapeKey: false,
                    confirmButtonText: 'OK, start calibration'
                });


                if (initIMU) {
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.IMU}`);
                    
                    let timerInterval;
                    await Swal.fire({
                        title: 'Calibrating...',
                        html: 'Wait for 5 seconds',
                        timer: 5000,
                        timerProgressBar: true,
                        allowOutsideClick: false,
                        allowEscapeKey: false,
                        didOpen: () => {
                            Swal.showLoading()
                        }
                    });

                    // Check IMU connection
                    const grepCommand = `grep 'Number of connected' ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt`;
                    const response = await fetch('/grep-command', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: grepCommand })
                    });
                    
                    const data = await response.json();
                    const numIMUs = parseInt(data.output.match(/\d+/)[0]);

                    if (numIMUs !== 3) {
                        await Swal.fire('ERROR', 'IMU not Connected', 'error');
                        // Cleanup IMU
                        sendFetchCommand(`source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rosnode kill -a`);
                    }
                }


                //Accendi il pilota
                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.PILOT}`);

                
                //Liberare spazio per muoversi all'indietro
                const { value: initBackward } = await Swal.fire({
                    title: 'Please ',
                    text: "Clear the space behind the robot.",
                    icon: 'warning',
                    showCancelButton: false,
                    allowOutsideClick: false,
                    allowEscapeKey: false,
                    confirmButtonText: 'OK'
                });


                if (initBackward) {
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BACKWARD}`);
                    
                    const loadingAlert = Swal.fire({
                        title: 'Moving Backward...',
                        text: 'Please wait',
                        allowOutsideClick: false,
                        allowEscapeKey: false,
                        didOpen: () => {
                            Swal.showLoading();
                            
                            // Check node status every second
                            const checkInterval = setInterval(async () => {
                                const isNodeActive = await checkNodeStatus(`/${robotName}/wheels/backward`);
                                if (!isNodeActive) {
                                    clearInterval(checkInterval);
                                    Swal.close();
                                }
                            }, 1000);
                        }
                    });

                    await loadingAlert;
                }

                // Start the loading state
                const loadingAlert = Swal.fire({
                    title: 'System Initialization',
                    text: 'Raise the robot and wait...',
                    allowOutsideClick: false,
                    allowEscapeKey: false,
                    didOpen: () => {
                        Swal.showLoading();
                    }
                });

                const isStable = await checkStability(robotName);
                if (isStable) {
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.WHEELS}`);
                    
                    // Remove the 5 second wait alert and just wait
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BODY_ACTIVATION}`);
                    const armsMoved = await waitForArmMovement(robotName);
                    
                    // Close the loading state
                    Swal.close();
                    
                    if (!armsMoved) {
                        await Swal.fire('Error', 'Arms did not activate properly', 'error');
                        return;
                    }
                    
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BODY_MOVEMENT}`);
                } else {
                    // Close the loading state if stability check failed
                    Swal.close();
                    await Swal.fire('Error', 'Could not achieve stability', 'error');
                }

            } 
            else {
                // Power off sequence
                sendFetchCommand('source /opt/ros/noetic/setup.bash && rosnode kill -a && killall -9 rosmaster && truncate -s 0 ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt');
                
                // Update UI
                powerBtn.classList.remove('on');
                startBtn.disabled = true;
                homeBtn.disabled = true;
                
                isRunning = false;
                saveButtonState('isRunning', false);
                startBtn.classList.remove('running');
                startBtn.innerHTML = '<i class="fas fa-play"></i><span>Start</span>';
                powerStatus.style.backgroundColor = '#ef4444';
                document.querySelector('#powerStatus + span').textContent = 'Power: Off';
                systemStatus.style.backgroundColor = '#eab308';
                document.querySelector('#systemStatus + span').textContent = 'Status: Ready';
            }
        });
        startBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            saveButtonState('isRunning', isRunning);
            if (isRunning) {
                startBtn.classList.add('running');
                startBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                systemStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#systemStatus + span').textContent = 'Status: Running';
            } else {
                startBtn.classList.remove('running');
                startBtn.innerHTML = '<i class="fas fa-play"></i><span>Start</span>';
                systemStatus.style.backgroundColor = '#eab308';
                document.querySelector('#systemStatus + span').textContent = 'Status: Ready';
            }
        });

    </script>
</body>
</html>