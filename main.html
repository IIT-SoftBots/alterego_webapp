<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Control Panel</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <style>

        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .control-button {
            width: 100%;
            aspect-ratio: 1;
            min-width: 120px;
            max-width: 200px;
            height: auto;
            border-radius: 15px;
            border: none;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: clamp(1rem, 2vw, 1.2rem);
            color: white;
            margin: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Aggiungi questa linea per l'ombra */
        }

        .control-button:hover {
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2); /* Ombra pi√π pronunciata al passaggio del mouse */
        }

        .control-button i {
            font-size: clamp(2rem, 4vw, 3rem);
            margin-bottom: 0.8rem;
        }
        .control-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .power-button {
            background-color: #ef4444;
        }

        .power-button.on {
            background-color: #22c55e;
        }

        .start-button {
            background-color: #3b82f6;
        }

        .start-button.running {
            background-color: #eab308;
        }

        .config-button {
            background-color: #8b5cf6;
        }

        .home-button {
            background-color: #14b8a6;
        }

        /* .reset-button {
            background-color: #f97316;
        } */

        .status-panel {
            margin-top: 2rem;
            padding: 1rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        body {
            background-image: url('/Adriano2.png');
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-size: cover;
            min-height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .title {
            color: white;
            text-align: center;
            margin: 2rem auto;  /* Changed from '2rem 0' to '2rem auto' */
            font-size: clamp(2rem, 4vw, 3rem);  /* Responsive font size */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);  /* Added shadow */
            font-weight: 600;  /* Makes the text slightly bolder */
            width: 100%;  /* Ensures full width for proper centering */
            padding: 0 1rem;  /* Adds some padding on the sides */
            position: relative;  /* Helps with positioning */
            z-index: 1;  /* Ensures title stays above other elements */
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            width: 100%;
            padding: 0 1rem;
        }
        @media screen and (max-width: 768px) {
            .button-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .control-button {
                min-width: 100px;
            }
        }

        @media screen and (max-width: 480px) {
            .button-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }

            .control-button {
                min-width: 80px;
                font-size: 0.9rem;
            }

            .control-button i {
                font-size: 1.8rem;
            }
        }

        .loading {
            opacity: 0;
            transition: opacity 0.3s ease-in;
        }

        .loaded {
            opacity: 1;
        }
    </style>
</head>



<body>
    <h1 class="title loading">Control Panel</h1>

    <div class="button-container loading">
        <div class="button-grid">
            <button id="powerBtn" class="control-button power-button">
                <i class="fas fa-power-off"></i>
                <span>Power</span>
            </button>
            
            <button id="startBtn" class="control-button start-button" disabled>
                <i class="fas fa-play"></i>
                <span>Start</span>
            </button>

            <button id="configBtn" class="control-button config-button" >
                <i class="fas fa-cog"></i>
                <span>Config</span>
            </button>

            <button id="homeBtn" class="control-button home-button" disabled>
                <i class="fas fa-home"></i>
                <span>Home</span>
            </button>

            <!-- <button id="resetBtn" class="control-button reset-button" >
                <i class="fas fa-undo"></i>
                <span>Reset</span>
            </button> -->
        </div>

        <div class="status-panel">
            <h3 style="margin-top: 0;">System Status</h3>
            <div class="status-item">
                <div id="powerStatus" class="status-indicator" style="background-color: #ef4444;"></div>
                <span>Power: Off</span>
            </div>
            <div class="status-item">
                <div id="batteryStatus" class="status-indicator" style="background-color: #22c55e;"></div>
                <span>Battery: 85%</span>
            </div>
            <div class="status-item">
                <div id="systemStatus" class="status-indicator" style="background-color: #eab308;"></div>
                <span>Status: Ready</span>
            </div>
        </div>
    </div>

    <script>
        const ROS_COMMANDS = {
            SETUP: 'source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash',
            CLEANUP: 'rosnode kill -a && killall -9 rosmaster',
            CLEAR_LOG: 'truncate -s 0 ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt'
        };

        const LAUNCH_COMMANDS = {
            ROSCORE: 'roscore',
            USB_DETECTOR: 'rosrun alterego_robot usb_ports_detector.py',
            IMU: 'roslaunch alterego_robot imu.launch AlterEgoVersion:=3',
            PILOT: 'roslaunch alterego_robot pilot.launch AlterEgoVersion:=3',
            BACKWARD: 'roslaunch alterego_backward_controller backward.launch AlterEgoVersion:=3',
            BODY_ACTIVATION: 'roslaunch alterego_robot body_activation.launch AlterEgoVersion:=3',
            BODY_MOVEMENT: 'roslaunch alterego_robot body_movement.launch AlterEgoVersion:=3',
            WHEELS: 'roslaunch alterego_robot wheels.launch AlterEgoVersion:=3'
        };

        // Aggiungi il codice per caricare lo stato al caricamento della pagina
        const initializeStates = () => {
        isPowered = loadButtonState('isPowered');
        isRunning = loadButtonState('isRunning');

        if (isPowered) {
            powerBtn.classList.add('on');
            startBtn.disabled = false;
            homeBtn.disabled = false;
            powerStatus.style.backgroundColor = '#22c55e';
            document.querySelector('#powerStatus + span').textContent = 'Power: On';
        }

        if (isRunning) {
            startBtn.classList.add('running');
            startBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
            systemStatus.style.backgroundColor = '#22c55e';
            document.querySelector('#systemStatus + span').textContent = 'Status: Running';
        }

        // Mostra il contenuto dopo l'inizializzazione
        document.querySelectorAll('.loading').forEach(el => {
            el.classList.add('loaded');
        });
    };
    
        // Esegui l'inizializzazione appena possibile
        document.addEventListener('DOMContentLoaded', initializeStates);


        const powerBtn = document.getElementById('powerBtn');
        const startBtn = document.getElementById('startBtn');
        const configBtn = document.getElementById('configBtn');
        const homeBtn = document.getElementById('homeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const powerStatus = document.getElementById('powerStatus');
        const systemStatus = document.getElementById('systemStatus');

        let isPowered = false;
        let isRunning = false;

        // Aggiungi queste funzioni per gestire il localStorage
        function saveButtonState(buttonId, state) {
            localStorage.setItem(buttonId, state);
        }

        function loadButtonState(buttonId) {
            return localStorage.getItem(buttonId) === 'true';
        }
        
        // Funzione per ottenere il nome del robot
        async function getRobotName() {
            const response = await fetch('/grep-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: 'grep -oP "(?<=export ROBOT_NAME=).*" ~/.bashrc' })
            });
            const data = await response.json();
            return data.output.trim();
        }
        async function checkNodeStatus(nodeName) {
            const response = await fetch('/grep-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rosnode list | grep ${nodeName}`
                })
            });
            const data = await response.json();
            return data.output.includes(nodeName);
        }
        async function getTopicValue(topic) {
            try {
                // Add retry mechanism
                let retries = 3;
                while (retries > 0) {
                    try {
                        const response = await fetch('/grep-command', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rostopic echo -n 1 ${topic}`
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (!data || !data.output) {
                            console.warn('No data received from topic:', topic);
                            return null;
                        }
                        
                        // Extract y value
                        const match = data.output.match(/y:\s*([-]?\d*\.?\d*)/);
                        if (!match) {
                            console.warn('Could not parse y value from:', data.output);
                            return null;
                        }
                        
                        return parseFloat(match[1]);
                    } catch (error) {
                        retries--;
                        if (retries === 0) throw error;
                        console.warn(`Retry attempt left: ${retries}`);
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
                    }
                }
            } catch (error) {
                console.error('Error reading topic:', error);
                // If it's an SSH error, try to reconnect
                if (error.message.includes('SSH') || error.message.includes('Channel open failure')) {
                    console.log('SSH connection lost, attempting to reconnect...');
                    // Notify user of connection issue
                    Swal.fire({
                        title: 'Connection Lost',
                        text: 'Attempting to reconnect...',
                        icon: 'warning',
                        showConfirmButton: false,
                        timer: 2000
                    });
                }
                return null;
            }
        }
        // First modify checkStability function to remove its loading alert
        async function checkStability(robotName) {
            return new Promise((resolve) => {
                let checkInterval;
                let consecutiveNullReadings = 0;
                const MAX_NULL_READINGS = 5;
                const POLLING_INTERVAL = 500;
                
                let stableStartTime = null;
                let lastCheckTime = Date.now();
                
                checkInterval = setInterval(async () => {
                    const now = Date.now();
                    if (now - lastCheckTime < POLLING_INTERVAL) {
                        return;
                    }
                    lastCheckTime = now;

                    try {
                        const value = await getTopicValue(`/${robotName}/imu/RPY`);
                        console.log('IMU value:', value, 'Time:', new Date().toISOString());
                        
                        if (value === null) {
                            consecutiveNullReadings++;
                            console.warn(`Null reading #${consecutiveNullReadings}`);
                            
                            if (consecutiveNullReadings >= MAX_NULL_READINGS) {
                                console.error('Too many failed readings, stopping stability check');
                                clearInterval(checkInterval);
                                resolve(false);
                                return;
                            }
                            return;
                        }
                        
                        consecutiveNullReadings = 0;
                        
                        if (value >= -0.3 && value <= 0.3) {
                            if (!stableStartTime) {
                                stableStartTime = Date.now();
                                console.log('Started stability timer');
                            }
                            
                            const stableTime = Date.now() - stableStartTime;
                            console.log('Stable for:', (stableTime/1000).toFixed(1), 'seconds');
                            
                            if (stableTime >= 2000) {
                                console.log('Stability achieved');
                                clearInterval(checkInterval);
                                resolve(true);
                                return;
                            }
                        } else {
                            if (stableStartTime) {
                                console.log('Stability lost, resetting timer');
                                stableStartTime = null;
                            }
                        }
                    } catch (error) {
                        console.error('Error in stability check:', error);
                    }
                }, POLLING_INTERVAL);
            });
        }
       // First, add this new function above the event listeners
        async function waitForArmMovement(robotName) {
            return new Promise((resolve) => {
                let checkInterval;
                const POLLING_INTERVAL = 500;

                const loadingAlert = Swal.fire({
                    title: 'Activating arms...',
                    text: 'Waiting for movement',
                    allowOutsideClick: false,
                    allowEscapeKey: false,
                    didOpen: () => {
                        Swal.showLoading();
                        
                        checkInterval = setInterval(async () => {
                            try {
                                const response = await fetch('/grep-command', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        command: `source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rostopic echo -n 1 /${robotName}/alterego_state/upperbody | grep left_meas_arm_shaft`
                                    })
                                });
                                
                                const data = await response.json();
                                if (data && data.output) {
                                    // Extract numbers from output
                                    const values = data.output.match(/[-]?\d*\.?\d+/g);
                                    if (values) {
                                        // Check if any value is non-zero
                                        const hasMovement = values.some(v => Math.abs(parseFloat(v)) > 0.01);
                                        console.log('Arm values:', values);
                                        
                                        if (hasMovement) {
                                            console.log('Movement detected');
                                            clearInterval(checkInterval);
                                            Swal.close();
                                            resolve(true);
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error checking arm movement:', error);
                            }
                        }, POLLING_INTERVAL);
                    },
                    willClose: () => {
                        clearInterval(checkInterval);
                    }
                });

                // Add timeout after 30 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    Swal.close();
                    resolve(false);
                }, 30000);
            });
        }

        // Modifica gli event listener esistenti
        powerBtn.addEventListener('click', async () => {
            isPowered = !isPowered;
            saveButtonState('isPowered', isPowered);

            if (isPowered) {
                // Check if remote computer is online
                const isRemoteComputerOnline = await pingRemoteComputer();
                if (!isRemoteComputerOnline) {
                    Swal.fire('ERROR', 'Base computer not connected', 'error');
                    isPowered = false;
                    saveButtonState('isPowered', false);
                    return;
                }


                
                // Ottieni il nome del robot
                const robotName = await getRobotName();

                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.ROSCORE}`);
                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.USB_DETECTOR}`);
                   // Update UI
                powerBtn.classList.add('on');
                startBtn.disabled = false;
                homeBtn.disabled = false;
                
                powerStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#powerStatus + span').textContent = 'Power: On';

                // Initialize IMU
                const { value: initIMU } = await Swal.fire({
                    title: 'Calibration in Progress',
                    text: "Do not touch the robot during calibration.",
                    icon: 'warning',
                    showCancelButton: false,
                    confirmButtonText: 'OK, start calibration'
                });


                if (initIMU) {
                    sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.IMU}`);
                    
                    let timerInterval;
                    await Swal.fire({
                        title: 'Calibrating...',
                        html: 'Wait for 5 seconds',
                        timer: 5000,
                        timerProgressBar: true,
                        didOpen: () => {
                            Swal.showLoading()
                        }
                    });

                    // Check IMU connection
                    const grepCommand = `grep 'Number of connected' ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt`;
                    const response = await fetch('/grep-command', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: grepCommand })
                    });
                    
                    const data = await response.json();
                    const numIMUs = parseInt(data.output.match(/\d+/)[0]);

                    if (numIMUs !== 3) {
                        await Swal.fire('ERROR', 'IMU not Connected', 'error');
                        // Cleanup IMU
                        sendFetchCommand(`source /opt/ros/noetic/setup.bash && source ~/catkin_ws/devel/setup.bash && rosnode kill -a`);
                    }
                }


                //Accendi il pilota
                sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.PILOT}`);

                
                //Liberare spazio per muoversi all'indietro
                const { value: initBackward } = await Swal.fire({
                    title: 'Please ',
                    text: "Clear the space behind the robot.",
                    icon: 'warning',
                    showCancelButton: false,
                    confirmButtonText: 'OK'
                });


                // if (initBackward) {
                //     sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BACKWARD}`);
                    
                //     const loadingAlert = Swal.fire({
                //         title: 'Moving Backward...',
                //         text: 'Please wait',
                //         allowOutsideClick: false,
                //         allowEscapeKey: false,
                //         didOpen: () => {
                //             Swal.showLoading();
                            
                //             // Check node status every second
                //             const checkInterval = setInterval(async () => {
                //                 const isNodeActive = await checkNodeStatus(`/${robotName}/wheels/backward`);
                //                 if (!isNodeActive) {
                //                     clearInterval(checkInterval);
                //                     Swal.close();
                //                 }
                //             }, 1000);
                //         }
                //     });

                //     await loadingAlert;
                // }


                // lo alzo e attivo le braccia 
                const { value: initWheels } = await Swal.fire({
                    title: 'Please ',
                    text: "Raise the robot.",
                    icon: 'warning',
                    showCancelButton: false,
                    confirmButtonText: 'OK'
                });

                // Then modify the initialization part in the power button click handler
                if (initWheels) {
                    // Start the loading state
                    const loadingAlert = Swal.fire({
                        title: 'System Initialization',
                        text: 'Please wait while the system initializes...',
                        allowOutsideClick: false,
                        allowEscapeKey: false,
                        didOpen: () => {
                            Swal.showLoading();
                        }
                    });

                    const isStable = await checkStability(robotName);
                    if (isStable) {
                        sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.WHEELS}`);
                        
                        // Remove the 5 second wait alert and just wait
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                        sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BODY_ACTIVATION}`);
                        const armsMoved = await waitForArmMovement(robotName);
                        
                        // Close the loading state
                        Swal.close();
                        
                        if (!armsMoved) {
                            await Swal.fire('Error', 'Arms did not activate properly', 'error');
                            return;
                        }
                        
                        sendFetchCommand(`${ROS_COMMANDS.SETUP} && export ROBOT_NAME=${robotName} && ${LAUNCH_COMMANDS.BODY_MOVEMENT}`);
                    } else {
                        // Close the loading state if stability check failed
                        Swal.close();
                        await Swal.fire('Error', 'Could not achieve stability', 'error');
                    }
                }

            } 
            else {
                // Power off sequence
                sendFetchCommand('source /opt/ros/noetic/setup.bash && rosnode kill -a && killall -9 rosmaster && truncate -s 0 ~/catkin_ws/src/AlterEGO_v2/alterego_robot/config/SystemCheck.txt');
                
                // Update UI
                powerBtn.classList.remove('on');
                startBtn.disabled = true;
                homeBtn.disabled = true;
                
                isRunning = false;
                saveButtonState('isRunning', false);
                startBtn.classList.remove('running');
                startBtn.innerHTML = '<i class="fas fa-play"></i><span>Start</span>';
                powerStatus.style.backgroundColor = '#ef4444';
                document.querySelector('#powerStatus + span').textContent = 'Power: Off';
                systemStatus.style.backgroundColor = '#eab308';
                document.querySelector('#systemStatus + span').textContent = 'Status: Ready';
            }
        });

        startBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            saveButtonState('isRunning', isRunning);
            if (isRunning) {
                startBtn.classList.add('running');
                startBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                systemStatus.style.backgroundColor = '#22c55e';
                document.querySelector('#systemStatus + span').textContent = 'Status: Running';
            } else {
                startBtn.classList.remove('running');
                startBtn.innerHTML = '<i class="fas fa-play"></i><span>Start</span>';
                systemStatus.style.backgroundColor = '#eab308';
                document.querySelector('#systemStatus + span').textContent = 'Status: Ready';
            }
        });
        function sendFetchCommand(command) {
            fetch('/execute', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ command: command }),
            })
            .then(response => response.text())
            .then(data => console.log(data))
            .catch(error => console.error('Error:', error));
        }
        function pingRemoteComputer() {
            return fetch('/ping', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ ip: '192.168.0.70' })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Ping successful:', data.success);
                return data.success;
            })
            .catch(error => {
                console.log('Ping failed:', error);
                return false;
            });
        }


    </script>
</body>
</html>